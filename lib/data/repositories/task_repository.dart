import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:studybuddy/data/models/task_model.dart';
import 'package:studybuddy/data/repositories/user_repository.dart';

class TaskRepository {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final FirebaseAuth _auth = FirebaseAuth.instance;
  final UserRepository _userRepository = UserRepository();

  // L·∫•y current user ID
  String? get _currentUserId => _auth.currentUser?.uid;

  // Mock data cho testing (ch·ªâ d√πng khi kh√¥ng c√≥ user)
  List<TaskModel> _mockTasks = [
    TaskModel(
      id: '1',
      title: 'L√†m b√†i t·∫≠p To√°n ch∆∞∆°ng 3',
      description: 'Ho√†n th√†nh c√°c b√†i t·∫≠p t·ª´ trang 45-50',
      subject: 'To√°n',
      deadline: DateTime.now().add(const Duration(days: 2)),
      isCompleted: false,
      priority: 2,
      createdAt: DateTime.now().subtract(const Duration(days: 1)),
    ),
    TaskModel(
      id: '2',
      title: '√în t·∫≠p t·ª´ v·ª±ng ti·∫øng Anh',
      description: 'H·ªçc 50 t·ª´ m·ªõi trong Unit 5',
      subject: 'Anh',
      deadline: DateTime.now().add(const Duration(days: 1)),
      isCompleted: true,
      priority: 1,
      createdAt: DateTime.now().subtract(const Duration(days: 2)),
      completedAt: DateTime.now().subtract(const Duration(hours: 2)),
    ),
    TaskModel(
      id: '3',
      title: 'ƒê·ªçc s√°ch VƒÉn h·ªçc',
      description: 'ƒê·ªçc v√† ph√¢n t√≠ch t√°c ph·∫©m "Truy·ªán Ki·ªÅu"',
      subject: 'VƒÉn',
      deadline: DateTime.now().add(const Duration(days: 3)),
      isCompleted: false,
      priority: 3,
      createdAt: DateTime.now().subtract(const Duration(days: 3)),
    ),
    TaskModel(
      id: '4',
      title: 'L√†m th√≠ nghi·ªám H√≥a h·ªçc',
      description: 'Th·ª±c h√†nh th√≠ nghi·ªám v·ªÅ ph·∫£n ·ª©ng oxi h√≥a kh·ª≠',
      subject: 'H√≥a',
      deadline: DateTime.now().subtract(const Duration(days: 1)),
      isCompleted: false,
      priority: 1,
      createdAt: DateTime.now().subtract(const Duration(days: 4)),
    ),
    TaskModel(
      id: '5',
      title: 'H·ªçc l√Ω thuy·∫øt V·∫≠t l√Ω',
      description: '√în t·∫≠p ch∆∞∆°ng ƒëi·ªán h·ªçc v√† t·ª´ h·ªçc',
      subject: 'L√Ω',
      deadline: DateTime.now().add(const Duration(days: 5)),
      isCompleted: false,
      priority: 2,
      createdAt: DateTime.now().subtract(const Duration(days: 5)),
    ),
  ];

  // L·∫•y t·∫•t c·∫£ b√†i t·∫≠p c·ªßa user hi·ªán t·∫°i
  Future<List<TaskModel>> getAllTasks() async {
    print('üîÑ TaskRepository: B·∫Øt ƒë·∫ßu getAllTasks()');
    
    // Ki·ªÉm tra user authentication
    final userId = _currentUserId;
    if (userId == null) {
      print('‚ö†Ô∏è TaskRepository: Kh√¥ng c√≥ user ƒëƒÉng nh·∫≠p, tr·∫£ v·ªÅ mock data');
      return _mockTasks;
    }
    
    print('üë§ TaskRepository: User ID: $userId');
    
    try {
      print('üì° TaskRepository: G·ªçi Firebase collection("tasks") v·ªõi userId filter...');
      
      // Query tasks theo userId
      final querySnapshot = await _firestore
          .collection('tasks')
          .where('userId', isEqualTo: userId)
          .get();
      
      final tasks = querySnapshot.docs
          .map((doc) {
            final data = doc.data() as Map<String, dynamic>;
            return TaskModel.fromJson({
              'id': doc.id,
              ...data,
            });
          })
          .toList();
      
      print('‚úÖ TaskRepository: Firebase tr·∫£ v·ªÅ ${tasks.length} tasks cho user $userId');
      return tasks;
    } catch (e) {
      print('‚ùå TaskRepository: Firebase error: $e, returning empty list');
      
      // Debug: Ki·ªÉm tra lo·∫°i l·ªói
      if (e.toString().contains('permission-denied')) {
        print('üîç TaskRepository: Permission denied - ki·ªÉm tra Firestore rules');
        print('üîç TaskRepository: Project ID: ${_firestore.app.options.projectId}');
        print('üîç TaskRepository: Collection: tasks');
        print('üîç TaskRepository: User ID: $userId');
      }
      
      return [];
    }
  }

  // L·∫•y b√†i t·∫≠p theo filter
  Future<List<TaskModel>> getTasksByFilter({
    String? subject,
    bool? isCompleted,
    DateTime? startDate,
    DateTime? endDate,
  }) async {
    final userId = _currentUserId;
    if (userId == null) {
      print('‚ö†Ô∏è TaskRepository: Kh√¥ng c√≥ user ƒëƒÉng nh·∫≠p, tr·∫£ v·ªÅ mock data');
      return _mockTasks;
    }
    
    try {
      Query query = _firestore.collection('tasks').where('userId', isEqualTo: userId);

      if (subject != null && subject.isNotEmpty) {
        query = query.where('subject', isEqualTo: subject);
      }

      if (isCompleted != null) {
        query = query.where('isCompleted', isEqualTo: isCompleted);
      }

      if (startDate != null) {
        query = query.where('deadline', isGreaterThanOrEqualTo: startDate);
      }

      if (endDate != null) {
        query = query.where('deadline', isLessThanOrEqualTo: endDate);
      }

      final querySnapshot = await query.orderBy('deadline').get();

      return querySnapshot.docs
          .map((doc) {
            final data = doc.data() as Map<String, dynamic>;
            return TaskModel.fromJson({
              'id': doc.id,
              ...data,
            });
          })
          .toList();
    } catch (e) {
      print('‚ùå TaskRepository: Firebase error: $e, returning empty list');
      return [];
    }
  }

  // L·∫•y b√†i t·∫≠p theo ID
  Future<TaskModel?> getTaskById(String taskId) async {
    final userId = _currentUserId;
    if (userId == null) {
      print('‚ö†Ô∏è TaskRepository: Kh√¥ng c√≥ user ƒëƒÉng nh·∫≠p, t√¨m trong mock data');
      try {
        return _mockTasks.firstWhere((task) => task.id == taskId);
      } catch (e) {
        return null;
      }
    }
    
    try {
      final doc = await _firestore.collection('tasks').doc(taskId).get();
      
      if (doc.exists) {
        final data = doc.data() as Map<String, dynamic>;
        // Ki·ªÉm tra xem task c√≥ thu·ªôc v·ªÅ user hi·ªán t·∫°i kh√¥ng
        if (data['userId'] == userId) {
          return TaskModel.fromJson({
            'id': doc.id,
            ...data,
          });
        } else {
          print('‚ö†Ô∏è TaskRepository: Task kh√¥ng thu·ªôc v·ªÅ user hi·ªán t·∫°i');
          return null;
        }
      }
      return null;
    } catch (e) {
      print('‚ùå TaskRepository: Firebase error: $e');
      return null;
    }
  }

  // Th√™m b√†i t·∫≠p m·ªõi
  Future<String> addTask(TaskModel task) async {
    final userId = _currentUserId;
    if (userId == null) {
      print('‚ö†Ô∏è TaskRepository: Kh√¥ng c√≥ user ƒëƒÉng nh·∫≠p, th√™m v√†o mock data');
      final newTask = task.copyWith(
        id: DateTime.now().millisecondsSinceEpoch.toString(),
        createdAt: DateTime.now(),
      );
      _mockTasks.insert(0, newTask);
      return newTask.id;
    }
    
    try {
      print('üìù TaskRepository: Th√™m task m·ªõi cho user $userId');
      
      // Th√™m userId v√†o task data
      final taskData = task.toJson();
      taskData['userId'] = userId;
      taskData['createdAt'] = DateTime.now().toIso8601String();
      
      final docRef = await _firestore.collection('tasks').add(taskData);
      print('‚úÖ TaskRepository: ƒê√£ th√™m task th√†nh c√¥ng v·ªõi ID: ${docRef.id}');
      return docRef.id;
    } catch (e) {
      print('‚ùå TaskRepository: Firebase error khi th√™m task: $e');
      rethrow;
    }
  }

  // C·∫≠p nh·∫≠t b√†i t·∫≠p
  Future<void> updateTask(String taskId, TaskModel task) async {
    final userId = _currentUserId;
    if (userId == null) {
      print('‚ö†Ô∏è TaskRepository: Kh√¥ng c√≥ user ƒëƒÉng nh·∫≠p, c·∫≠p nh·∫≠t mock data');
      final index = _mockTasks.indexWhere((t) => t.id == taskId);
      if (index != -1) {
        _mockTasks[index] = task;
      }
      return;
    }
    
    try {
      print('üìù TaskRepository: C·∫≠p nh·∫≠t task $taskId cho user $userId');
      
      // Ki·ªÉm tra quy·ªÅn s·ªü h·ªØu tr∆∞·ªõc khi update
      final doc = await _firestore.collection('tasks').doc(taskId).get();
      if (!doc.exists) {
        print('‚ùå TaskRepository: Task kh√¥ng t·ªìn t·∫°i');
        return;
      }
      
      final data = doc.data();
      if (data?['userId'] != userId) {
        print('‚ùå TaskRepository: Task kh√¥ng thu·ªôc v·ªÅ user hi·ªán t·∫°i');
        return;
      }
      
      // Th√™m userId v√†o task data
      final taskData = task.toJson();
      taskData['userId'] = userId;
      
      await _firestore.collection('tasks').doc(taskId).update(taskData);
      print('‚úÖ TaskRepository: ƒê√£ c·∫≠p nh·∫≠t task th√†nh c√¥ng');
    } catch (e) {
      print('‚ùå TaskRepository: Firebase error khi c·∫≠p nh·∫≠t task: $e');
      rethrow;
    }
  }

  // X√≥a b√†i t·∫≠p
  Future<void> deleteTask(String taskId) async {
    final userId = _currentUserId;
    if (userId == null) {
      print('‚ö†Ô∏è TaskRepository: Kh√¥ng c√≥ user ƒëƒÉng nh·∫≠p, x√≥a kh·ªèi mock data');
      _mockTasks.removeWhere((task) => task.id == taskId);
      return;
    }
    
    try {
      print('üóëÔ∏è TaskRepository: X√≥a task $taskId cho user $userId');
      
      // Ki·ªÉm tra quy·ªÅn s·ªü h·ªØu tr∆∞·ªõc khi x√≥a
      final doc = await _firestore.collection('tasks').doc(taskId).get();
      if (!doc.exists) {
        print('‚ùå TaskRepository: Task kh√¥ng t·ªìn t·∫°i');
        return;
      }
      
      final data = doc.data();
      if (data?['userId'] != userId) {
        print('‚ùå TaskRepository: Task kh√¥ng thu·ªôc v·ªÅ user hi·ªán t·∫°i');
        return;
      }
      
      await _firestore.collection('tasks').doc(taskId).delete();
      print('‚úÖ TaskRepository: ƒê√£ x√≥a task th√†nh c√¥ng');
    } catch (e) {
      print('‚ùå TaskRepository: Firebase error khi x√≥a task: $e');
      rethrow;
    }
  }

  // Toggle completion status
  Future<void> toggleTaskCompletion(String taskId, bool isCompleted) async {
    print('üîÑ TaskRepository: B·∫Øt ƒë·∫ßu toggleTaskCompletion()');
    print('üìã TaskRepository: TaskID: $taskId, isCompleted: $isCompleted');
    
    final userId = _currentUserId;
    if (userId == null) {
      print('‚ö†Ô∏è TaskRepository: Kh√¥ng c√≥ user ƒëƒÉng nh·∫≠p, kh√¥ng th·ªÉ toggle');
      return;
    }
    
    try {
      print('üì° TaskRepository: T√¨m document theo task ID: $taskId');
      
      // T√¨m document theo task ID trong data thay v√¨ document ID
      final querySnapshot = await _firestore
          .collection('tasks')
          .where('userId', isEqualTo: userId)
          .where('id', isEqualTo: taskId)
          .get();
      
      if (querySnapshot.docs.isEmpty) {
        print('‚ùå TaskRepository: Kh√¥ng t√¨m th·∫•y document v·ªõi task ID: $taskId');
        print('üîç TaskRepository: Ki·ªÉm tra t·∫•t c·∫£ documents trong collection...');
        
        // Ki·ªÉm tra t·∫•t c·∫£ documents ƒë·ªÉ debug
        final allDocs = await _firestore.collection('tasks').where('userId', isEqualTo: userId).get();
        print('üìä TaskRepository: T·ªïng s·ªë documents c·ªßa user $userId: ${allDocs.docs.length}');
        for (final doc in allDocs.docs) {
          print('  - Document ID: ${doc.id}');
          print('  - Document data: ${doc.data()}');
        }
        
        print('‚ùå TaskRepository: Kh√¥ng t·∫°o task m·ªõi, ch·ªâ c·∫≠p nh·∫≠t task hi·ªán c√≥');
        return;
      }
      
      final docRef = querySnapshot.docs.first.reference;
      final docSnapshot = querySnapshot.docs.first;
      
      print('‚úÖ TaskRepository: T√¨m th·∫•y document: ${docRef.path}');
      print('üìä TaskRepository: Document exists: ${docSnapshot.exists}');
      
      // Ki·ªÉm tra quy·ªÅn s·ªü h·ªØu
      final data = docSnapshot.data();
      print('üìä TaskRepository: Document data hi·ªán t·∫°i: $data');
      
      if (data?['userId'] != userId) {
        print('‚ùå TaskRepository: Task kh√¥ng thu·ªôc v·ªÅ user hi·ªán t·∫°i');
        print('üìä TaskRepository: Document userId: ${data?['userId']}');
        print('üìä TaskRepository: Current userId: $userId');
        return;
      }
      
      print('‚úÖ TaskRepository: Document t·ªìn t·∫°i, b·∫Øt ƒë·∫ßu update...');
      print('üìä TaskRepository: Tr·∫°ng th√°i c≈©: ${data?['isCompleted']}');
      print('üìä TaskRepository: Tr·∫°ng th√°i m·ªõi: $isCompleted');
      
      // C·∫≠p nh·∫≠t isCompleted v√† completedAt
      final now = DateTime.now();
      final updateData = {
        'isCompleted': isCompleted,
        'completedAt': isCompleted ? now.toIso8601String() : null,
        'userId': userId, // ƒê·∫£m b·∫£o userId ƒë∆∞·ª£c c·∫≠p nh·∫≠t
      };
      
      print('üìä TaskRepository: Update data: $updateData');
      print('üìä TaskRepository: completedAt s·∫Ω set: ${isCompleted ? now.toIso8601String() : "null"}');
      
      await docRef.update(updateData);
      print('‚úÖ TaskRepository: Firebase update th√†nh c√¥ng!');
      print('üìä TaskRepository: ƒê√£ c·∫≠p nh·∫≠t isCompleted = $isCompleted, completedAt = ${isCompleted ? now.toIso8601String() : "null"}');

      // C·∫≠p nh·∫≠t consecutive days n·∫øu task ƒë∆∞·ª£c ho√†n th√†nh
      if (isCompleted) {
        print('üîÑ TaskRepository: Task ho√†n th√†nh, c·∫≠p nh·∫≠t consecutive days...');
        await _userRepository.updateConsecutiveDays();
      }

      // Verify update
      final updatedDoc = await docRef.get();
      final updatedData = updatedDoc.data();
      print('‚úÖ TaskRepository: Verify - isCompleted sau update: ${updatedData?['isCompleted']}');
      print('‚úÖ TaskRepository: Verify - completedAt sau update: ${updatedData?['completedAt']}');
      print('‚úÖ TaskRepository: Verify - userId sau update: ${updatedData?['userId']}');
      print('‚úÖ TaskRepository: Verify - to√†n b·ªô data: $updatedData');
      
      // Ki·ªÉm tra xem update c√≥ th√†nh c√¥ng kh√¥ng
      if (updatedData?['isCompleted'] != isCompleted) {
        print('‚ùå TaskRepository: Update kh√¥ng th√†nh c√¥ng!');
        print('üìä TaskRepository: Expected isCompleted: $isCompleted');
        print('üìä TaskRepository: Actual isCompleted: ${updatedData?['isCompleted']}');
      } else {
        print('‚úÖ TaskRepository: Update th√†nh c√¥ng! isCompleted ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t ƒë√∫ng');
      }
    } catch (e) {
      print('‚ùå TaskRepository: Firebase error khi toggle: $e');
      rethrow;
    }
  }

  // L·∫•y th·ªëng k√™ b√†i t·∫≠p
  Future<Map<String, dynamic>> getTaskStatistics() async {
    final userId = _currentUserId;
    if (userId == null) {
      print('‚ö†Ô∏è TaskRepository: Kh√¥ng c√≥ user ƒëƒÉng nh·∫≠p, t√≠nh to√°n t·ª´ mock data');
      return _calculateStatistics(_mockTasks);
    }
    
    try {
      print('üìä TaskRepository: B·∫Øt ƒë·∫ßu t√≠nh to√°n th·ªëng k√™ cho user: $userId');
      final querySnapshot = await _firestore.collection('tasks').where('userId', isEqualTo: userId).get();
      
      final tasks = querySnapshot.docs
          .map((doc) {
            final data = doc.data() as Map<String, dynamic>;
            // S·ª≠ d·ª•ng data['id'] thay v√¨ doc.id ƒë·ªÉ ƒë·∫£m b·∫£o ƒë√∫ng task ID
            final taskId = data['id'] ?? doc.id;
            return TaskModel.fromJson({
              'id': taskId,
              ...data,
            });
          })
          .toList();

      print('üìä TaskRepository: T·ªïng s·ªë tasks: ${tasks.length}');
      for (final task in tasks) {
        print('üìã TaskRepository: Task "${task.title}" (ID: ${task.id}): isCompleted = ${task.isCompleted}');
      }

      final statistics = _calculateStatistics(tasks);
      print('üìä TaskRepository: Th·ªëng k√™: $statistics');
      return statistics;
    } catch (e) {
      print('‚ùå TaskRepository: Firebase error: $e, returning empty statistics');
      return _calculateStatistics([]);
    }
  }

  Map<String, dynamic> _calculateStatistics(List<TaskModel> tasks) {
    final totalTasks = tasks.length;
    final completedTasks = tasks.where((task) => task.isCompleted).length;
    final pendingTasks = totalTasks - completedTasks;
    final overdueTasks = tasks
        .where((task) => !task.isCompleted && task.deadline.isBefore(DateTime.now()))
        .length;

    return {
      'totalTasks': totalTasks,
      'completedTasks': completedTasks,
      'pendingTasks': pendingTasks,
      'overdueTasks': overdueTasks,
      'completionRate': totalTasks > 0 ? completedTasks / totalTasks : 0.0,
    };
  }
}
